import mlflow
import os
from mlflow.models import infer_signature
from mlflow.tracking import MlflowClient

class MLflowManager:
    def __init__(self, tracking_uri="sqlite:///mlflow.db", experiment_name="Email_Spam_Detection"):
        # On d√©finit le chemin absolu pour que le backend trouve la DB peu importe d'o√π il appelle le code
        abs_tracking_uri = os.path.abspath(tracking_uri.replace("sqlite:///", ""))
        mlflow.set_tracking_uri(f"sqlite:///{abs_tracking_uri}")
        
        mlflow.set_experiment(experiment_name)
        self.client = MlflowClient()

    def log_training_run(self, model, params, metrics, X_sample, model_name="SpamClassifier"):
        with mlflow.start_run() as run:
            signature = infer_signature(X_sample, model.predict(X_sample))
            
            mlflow.log_params(params)
            mlflow.log_metrics(metrics)

            # Log du mod√®le
            mlflow.sklearn.log_model(
                sk_model=model,
                artifact_path="model",
                registered_model_name=model_name,
                signature=signature
            )

            if os.path.exists("confusion_matrix.png"):
                mlflow.log_artifact("confusion_matrix.png")

            # On retourne l'URI de la version qui vient d'√™tre cr√©√©e
            return self.get_model_uri(model_name, stage="None")

    def get_model_uri(self, model_name="SpamClassifier", stage="Production"):
        """
        Retourne l'URI du mod√®le. 
        Par d√©faut, cherche le mod√®le en 'Production'. 
        Si stage="None", cherche la toute derni√®re version.
        """
        try:
            if stage == "None":
                # R√©cup√®re la derni√®re version sans filtre de stage
                versions = self.client.get_latest_versions(model_name, stages=["None"])
            else:
                # R√©cup√®re la version en Production
                versions = self.client.get_latest_versions(model_name, stages=[stage])

            if versions:
                latest_version = versions[0].version
                return f"models:/{model_name}/{latest_version}"
            else:
                return f"Aucun mod√®le trouv√© pour {model_name}"
        except Exception as e:
            return f"Erreur lors de la r√©cup√©ration de l'URI : {e}"

    def promote_to_production(self, model_name, version):
        self.client.transition_model_version_stage(
            name=model_name,
            version=version,
            stage="Production",
            archive_existing_versions=True
        )
        print(f"üöÄ Mod√®le {model_name} version {version} pass√© en Production.")